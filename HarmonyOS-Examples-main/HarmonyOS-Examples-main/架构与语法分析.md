# HarmonyOS 仓颉语言示例项目架构与语法分析

## 一、项目概述

本项目是 HarmonyOS 官方示例集合，使用**仓颉（Cangjie）语言**开发。仓颉是华为为 HarmonyOS 设计的新一代应用编程语言，采用声明式 UI 开发范式。

### 1.1 项目结构

每个示例项目遵循标准的 HarmonyOS 项目结构：

```
项目根目录/
├── AppScope/                    # 应用级配置
│   ├── app.json5               # 应用配置
│   └── resources/              # 应用级资源
├── entry/                       # 主模块
│   ├── src/main/
│   │   ├── cangjie/            # 仓颉源代码目录
│   │   │   ├── src/
│   │   │   │   ├── index.cj    # 入口页面
│   │   │   │   ├── main_ability.cj    # 主 Ability
│   │   │   │   ├── ability_stage.cj   # Ability 生命周期
│   │   │   │   ├── components/  # UI 组件
│   │   │   │   ├── pages/      # 页面组件
│   │   │   │   ├── utils/      # 工具类
│   │   │   │   └── entity/     # 实体类
│   │   │   └── cjpm.toml       # 仓颉包管理配置
│   │   ├── module.json5        # 模块配置
│   │   └── resources/          # 资源文件
├── build-profile.json5         # 构建配置
├── oh-package.json5            # 依赖管理
└── hvigorfile.ts              # 构建脚本
```

### 1.2 核心配置文件

#### `module.json5` - 模块配置
```json5
{
  "module": {
    "name": "entry",
    "type": "entry",
    "mainElement": "EntryAbility",
    "srcEntry": "ohos_app_cangjie_entry.MyAbilityStage",  // AbilityStage 入口
    "abilities": [
      {
        "name": "EntryAbility",
        "srcEntry": "ohos_app_cangjie_entry.MainAbility",  // Ability 入口
        "exported": true,
        "skills": [
          {
            "entities": ["entity.system.home"],
            "actions": ["action.system.home"]
          }
        ]
      }
    ]
  }
}
```

#### `cjpm.toml` - 仓颉包管理
```toml
[package]
name = "ohos_app_cangjie_entry"
version = "1.0.0"
cjc-version = "0.48.2"
output-type = "dynamic"
src-dir = "src"

[dependencies]
[dependencies.cj_res_entry]
path = "./cj_res"
version = "1.0.0"
```

## 二、仓颉语言核心语法

### 2.1 包声明与导入

```cangjie
package ohos_app_cangjie_entry

import ohos.base.*
import ohos.component.*
import ohos.state_manage.*
import ohos.state_macro_manage.*
import std.collection.*
```

### 2.2 组件定义

#### 基本组件结构
```cangjie
@Entry          // 入口组件装饰器
@Component      // 组件装饰器
class EntryView {
    // 状态变量
    @State
    var items: ArrayList<ButtonEntity> = ArrayList()
    
    // 生命周期方法
    public func aboutToAppear(): Unit {
        // 组件即将显示时的初始化
    }
    
    // 构建方法（必需）
    func build() {
        Column() {
            // UI 内容
        }
    }
}
```

### 2.3 状态管理

#### @State - 组件内部状态
```cangjie
@Entry
@Component
class EntryView {
    @State
    var count: Int64 = 0
    
    @State
    var text: String = "Hello"
    
    func build() {
        Column() {
            Text("${count}")
            Button("增加") {
                count++
            }
        }
    }
}
```

#### @Observed 和 @Publish - 可观察对象
```cangjie
@Observed
public class DynamicParam {
    @Publish
    public var expressionText: String = "0"
    
    @Publish
    public var resultText: String = "0"
    
    public func push(text: String) {
        expressionText = expressionText + text
        // @Publish 标记的变量变化会自动触发 UI 更新
    }
}
```

#### AppStorage - 应用级状态存储
```cangjie
// 创建或获取存储
let storageHistory = AppStorage.setOrCreate("history", ObservedArrayList<String>([]))
let storageThemeIndex = AppStorage.setOrCreate("themeIndex", 0)

// 在组件中使用
@StorageLink["history"]
var history: ObservedArrayList<String> = ObservedArrayList<String>([])

@StorageLink["themeIndex"]
var themeIndex: Int64 = 0
```

#### LocalStorage - 组件树级状态共享
```cangjie
// 创建 LocalStorage
let storage = LocalStorage()

@Entry[storage]  // 关联到根组件
@Component
class EntryView {
    func build() {
        Column() {
            ChildComponent()
        }
    }
}

// 子组件中链接状态
@Component
class ChildComponent {
    @LocalStorageLink['viewModel']
    var viewModel: SeatSelection = SeatSelection()
    
    func build() {
        // 使用共享的 viewModel
    }
}
```

### 2.4 UI 组件系统

#### 基础布局组件
```cangjie
// Column - 垂直布局
Column(20) {  // 20 为子组件间距
    Text("第一行")
    Text("第二行")
}
.width(100.percent)
.padding(20)
.alignItems(HorizontalAlign.Center)

// Row - 水平布局
Row(20) {
    Text("左")
    Text("右")
}
.justifyContent(FlexAlign.SpaceBetween)

// Stack - 层叠布局
Stack(Alignment.Bottom) {
    Image(...)
    Text("水印")
}

// Grid - 网格布局
Grid {
    ForEach(items, itemGeneratorFunc: { item, index =>
        GridItem {
            Button(item.text)
        }
    })
}
.rowsTemplate('1fr 1fr 1fr 1fr')
.columnsTemplate('1fr 1fr 1fr 1fr')
.columnsGap(8)
.rowsGap(8)
```

#### 基础 UI 组件
```cangjie
// Text - 文本
Text("仓颉")
    .fontSize(32.px)
    .fontColor(0xCCCCCC)
    .fontWeight(FontWeight.Bold)

// Button - 按钮
Button("点击")
    .shape(ShapeType.Normal)
    .borderRadius(8)
    .backgroundColor(0x0065ff)
    .onClick({ e: ClickEvent =>
        // 处理点击事件
    })

// Image - 图片
Image(@r(app.media.icon))  // 使用资源引用
    .width(100)
    .height(100)
    .borderRadius(50)

// TextInput - 输入框
TextInput(placeholder: "请输入")
    .fontSize(24)
    .borderRadius(6)
    .onChange({ value: String =>
        // 处理输入变化
    })

// Scroll - 滚动容器
Scroll() {
    Column() {
        // 可滚动内容
    }
}
.scrollable(ScrollDirection.Vertical)
```

#### ForEach - 列表渲染
```cangjie
ForEach(
    items,  // 数据源
    itemGeneratorFunc: { item: ButtonEntity, index: Int64 =>
        Button(item.text)
            .onClick({ e => item.onPress() })
    }
)
```

### 2.5 扩展方法（Extension）

仓颉支持通过 `extend` 关键字为现有类型添加方法：

```cangjie
// 为 Column 添加扩展方法
extend Column {
    func card() {
        this.borderRadius(10)
            .justifyContent(FlexAlign.SpaceBetween)
            .alignItems(HorizontalAlign.Start)
    }
    
    func redirect(url: String) {
        this.onClick({
            e: ClickEvent => Router.push(url: url)
        })
    }
}

// 为 Button 添加扩展方法
extend Button {
    func rounded() {
        this.shape(ShapeType.Normal)
            .borderRadius(6.fp)
    }
    
    func jump(url: String) {
        this.fontSize(25)
            .height(50)
            .width(70.percent)
            .onClick {
                Router.push(url: url)
            }
    }
}

// 使用扩展方法
Column() {
    Button("跳转").jump("TargetView")
}
.card()
.redirect("DetailView")
```

### 2.6 路由与导航

```cangjie
import ohos.router.Router

// 跳转到指定页面
Router.push(url: "TargetView", params: "参数")

// 返回上一页
Router.back()

// 返回指定页面
Router.back(url: "PreviousView")

// 获取路由参数
@State var label: String = Router.getParams().getOrThrow()
```

### 2.7 类型系统

#### 基本类型
```cangjie
let number: Int64 = 100
let text: String = "Hello"
let flag: Bool = true
let decimal: Float64 = 3.14
```

#### 集合类型
```cangjie
// 数组
let array: Array<Int64> = [1, 2, 3]

// 列表
let list: ArrayList<String> = ArrayList(["a", "b", "c"])

// 映射
let map: HashMap<String, Int64> = HashMap([
    ("key1", 1),
    ("key2", 2)
])

// 可观察数组（用于状态管理）
@State
var items: ObservedArrayList<Item> = ObservedArrayList<Item>()
```

#### 枚举类型
```cangjie
enum ChatState {
    New | History | Modified
}

enum IOState {
    Empty | Input | Output
    
    func icon(): CJResource {
        match (this) {
            case Empty => @r(app.media.send_disable)
            case Input => @r(app.media.send_enable)
            case Output => @r(app.media.stop)
        }
    }
}
```

#### 元组类型
```cangjie
type State = (ChatState, IOState)

let state: State = (New, Input)
```

### 2.8 模式匹配（Match）

```cangjie
match (value) {
    case 1 => doSomething()
    case 2 | 3 => doOtherThing()
    case _ => defaultAction()
}

// 在计算器示例中
match (token) {
    case '+' => stack.push(a + b)
    case '-' => stack.push(a - b)
    case '*' | 'x' => stack.push(a * b)
    case _ => stack.push(a / b)  // '/' | '÷'
}
```

### 2.9 类与继承

```cangjie
// 基类
public open class ButtonEntity {
    public var bgColor: Color = Color(0)
    public var textColor: Color = Color(0)
    
    public ButtonEntity(public let text: String) {}
    
    public open func onPress(dynamicParam: DynamicParam) {
        // 默认实现
    }
}

// 子类
public class NumberButton <: ButtonEntity {
    public init(text: String) {
        super(text)
        bgColor = Color(0xFFFFFF)
    }
    
    public override func onPress(dynamicParam: DynamicParam) {
        dynamicParam.push(text)
    }
}
```

### 2.10 资源引用

```cangjie
// 字符串资源
Text($string:app_name)

// 颜色资源
.backgroundColor(@r(app.color.primary))

// 图片资源
Image(@r(app.media.icon))

// 尺寸资源
.width(@r(app.float.button_width))
```

## 三、架构模式

### 3.1 MVVM 架构

项目采用经典的 MVVM（Model-View-ViewModel）架构：

```
┌─────────────┐
│    View     │  UI 组件（Component）
│  (index.cj) │
└──────┬──────┘
       │ @LocalStorageLink / @State
       │
┌──────▼──────────┐
│   ViewModel     │  业务逻辑和状态管理
│ (SeatSelection) │  @Observed + @Publish
└──────┬──────────┘
       │
┌──────▼──────┐
│    Model    │  数据模型和工具类
│  (Entity)   │
└─────────────┘
```

#### ViewModel 示例
```cangjie
@Observed
public class SeatSelection {
    @Publish 
    public var seatsState: ObservedArrayList<ObservedArray<SEAT_TYPE>> = ...
    
    @Publish 
    public var selectedSeats: ObservedArrayList<SeatInfo> = ObservedArrayList<SeatInfo>()
    
    public func handleSeatClick(seatInfo: SeatInfo) {
        // 业务逻辑
        if (seatInfo.isSelected) {
            selectedSeats.remove(seatInfo)
        } else {
            selectedSeats.append(seatInfo)
        }
        // UI 会自动更新
    }
}
```

### 3.2 组件化设计

#### 组件层次结构
```
EntryView (入口)
├── HeaderComponent (头部)
├── ContentComponent (内容)
│   ├── ListComponent (列表)
│   └── DetailComponent (详情)
└── FooterComponent (底部)
```

#### 组件通信
- **父子通信**: 通过构造函数传递参数
- **兄弟通信**: 通过共享的 ViewModel 或 LocalStorage
- **跨层级通信**: 使用 AppStorage 或事件总线

### 3.3 数据流

```
用户操作
   ↓
事件处理 (onClick, onChange)
   ↓
ViewModel 更新状态 (@Publish)
   ↓
UI 自动重新渲染
   ↓
显示新状态
```

## 四、关键特性

### 4.1 声明式 UI

仓颉采用声明式 UI 编程范式：

```cangjie
// 声明式：描述 UI 应该是什么样子
func build() {
    Column() {
        if (count > 0) {
            Text("${count}")
        } else {
            Text("无数据")
        }
    }
}

// 当 count 变化时，UI 自动更新
// 无需手动操作 DOM 或调用 setState
```

### 4.2 响应式状态

状态变化自动触发 UI 更新：

```cangjie
@State var count: Int64 = 0

func build() {
    Column() {
        Text("${count}")  // 自动响应 count 的变化
        Button("增加") {
            count++  // 修改状态，UI 自动更新
        }
    }
}
```

### 4.3 类型安全

强类型系统提供编译时类型检查：

```cangjie
let items: ArrayList<ButtonEntity> = ArrayList()
// 类型不匹配会在编译时报错
```

### 4.4 函数式编程支持

```cangjie
// 管道操作符
chatHistory[index].messages 
    |> map { item => (item.role, item.content) }
    |> collectArray 
    |> robot.preset

// 高阶函数
items.map { item => item.transform() }
items.filter { item => item.isValid() }
```

## 五、最佳实践

### 5.1 状态管理最佳实践

1. **组件内部状态使用 @State**
   ```cangjie
   @State var localCount: Int64 = 0
   ```

2. **跨组件共享使用 LocalStorage**
   ```cangjie
   let storage = LocalStorage()
   @Entry[storage]
   ```

3. **应用级状态使用 AppStorage**
   ```cangjie
   let storageTheme = AppStorage.setOrCreate("theme", 0)
   ```

4. **复杂状态使用 @Observed + @Publish**
   ```cangjie
   @Observed
   class ViewModel {
       @Publish var data: ObservedArrayList<Item> = ...
   }
   ```

### 5.2 组件设计最佳实践

1. **单一职责**: 每个组件只负责一个功能
2. **可复用性**: 通过参数化提高组件复用性
3. **扩展方法**: 使用 extend 封装常用样式
4. **组件拆分**: 复杂组件拆分为多个小组件

### 5.3 代码组织最佳实践

```
src/
├── index.cj              # 入口页面
├── main_ability.cj       # Ability 入口
├── ability_stage.cj      # AbilityStage
├── components/           # UI 组件
│   ├── common/          # 通用组件
│   └── specific/        # 特定功能组件
├── pages/               # 页面组件
├── view_model/          # ViewModel
├── entity/              # 数据模型
├── utils/               # 工具类
└── constants/           # 常量定义
```

### 5.4 性能优化

1. **使用 ObservedArray 而非普通 Array**
   ```cangjie
   @State var items: ObservedArrayList<Item> = ObservedArrayList<Item>()
   ```

2. **避免在 build() 中进行复杂计算**
   ```cangjie
   // 不好
   func build() {
       let result = expensiveCalculation()  // 每次 build 都计算
   }
   
   // 好
   @State var result: Int64 = 0
   func aboutToAppear() {
       result = expensiveCalculation()  // 只计算一次
   }
   ```

3. **合理使用条件渲染**
   ```cangjie
   if (condition) {
       ComponentA()
   } else {
       ComponentB()
   }
   ```

## 六、示例项目分析

### 6.1 HelloWord (01-HelloWord)
- **功能**: 基础示例，展示随机汉字瀑布流
- **要点**: 
  - 基本的 @Entry 和 @Component 使用
  - ForEach 列表渲染
  - 随机数生成

### 6.2 UIComponent (02-UIComponent)
- **功能**: UI 组件展示和交互
- **要点**:
  - 各种 UI 组件的使用方法
  - 扩展方法的使用
  - 路由跳转

### 6.3 Calculator (04-Calculator)
- **功能**: 计算器应用
- **要点**:
  - @Observed 和 @Publish 的使用
  - 业务逻辑封装
  - Grid 布局
  - 表达式解析和计算

### 6.4 SeatSelection (13-SeatSelection)
- **功能**: 电影选座
- **要点**:
  - MVVM 架构完整示例
  - LocalStorage 状态共享
  - Canvas 命令式绘图
  - 声明式 UI 与命令式 UI 结合

### 6.5 DeepSeek (07-DeepSeek)
- **功能**: AI 聊天应用
- **要点**:
  - 异步操作（网络请求）
  - 文件读写
  - 复杂状态管理
  - 数据持久化

## 七、异步操作与网络请求

### 7.1 并发与协程

#### spawn - 创建异步任务
```cangjie
import ohos.concurrency.launch

// 创建异步任务
var taskThread: Option<Future<Unit>> = None

taskThread = spawn {
    // 在后台线程执行
    let result = expensiveOperation()
    
    // 切换到主线程更新 UI
    launch {
        // 在主线程中更新状态
        this.data = result
    }
}

// 取消任务
if (let Some(future) <- taskThread) {
    future.cancel()
    future.get()
    taskThread = None
}
```

#### launch - 主线程调度
```cangjie
import ohos.concurrency.launch

// 在后台线程中执行操作
spawn {
    let data = fetchData()
    
    // 切换到主线程更新 UI
    launch {
        this.items = data  // 安全地更新 UI
    }
}
```

#### 任务取消检查
```cangjie
spawn {
    while (true) {
        if (Thread.currentThread.hasPendingCancellation) {
            return  // 检查取消标志
        }
        // 执行操作
    }
}
```

### 7.2 网络请求

#### HTTP 请求基础用法
```cangjie
import ohos.net.http.*
import std.collection.HashMap

let httpRequest = createHttp()

httpRequest.request(
    url,
    {
        err, resp =>
        if (let Some(e) <- err) {
            // 处理错误
            Hilog.error(0, "http", "exception: ${e.message}")
            return
        }
        if (let Some(r) <- resp) {
            if (r.responseCode.getValue() == 200) {
                // 处理响应
                let result = r.result.toString()
                // 更新 UI
            }
        }
        httpRequest.destroy()
    }
)
```

#### 带选项的 HTTP 请求
```cangjie
let option = HttpRequestOptions(
    expectDataType: HttpDataType.STRING,
    header: HashMap<String, String>([
        ("Authorization", "Bearer ${token}"),
        ("Content-Type", "application/json")
    ])
)

httpRequest.request(
    url,
    {
        err, resp => /* 处理响应 */
    },
    options: option
)
```

#### 使用 HTTP Client（推荐方式）
```cangjie
import net.http.*
import net.tls.*
import std.time.Duration

// 创建客户端
var config = TlsClientConfig()
config.verifyMode = TrustAll

let client = ClientBuilder()
    .tlsConfig(config)
    .readTimeout(Duration.second * 30)
    .build()

// 构建请求
let request = HttpRequestBuilder()
    .url('https://api.example.com/endpoint')
    .header('Authorization', 'Bearer ${apiKey}')
    .header('Content-Type', 'application/json')
    .body('{"key": "value"}')
    .post()
    .build()

// 发送请求
let response = client.send(request)

// 处理响应
match (response) {
    case Some(r) => {
        let data = r.body.toString()
        // 处理数据
    }
    case None => {
        // 处理错误
    }
}
```

#### 流式响应处理
```cangjie
// 在 LLM 聊天示例中
robot.chat(message) { slice: String, reason: Bool =>
    // 检查取消
    if (Thread.currentThread.hasPendingCancellation) {
        return false
    }
    
    // 在主线程更新 UI
    launch {
        if (reason) {
            reasons += slice  // 思维链内容
        } else {
            output += slice   // 正常输出
        }
        scroller.scrollEdge(Edge.Bottom)
    }
    return true
}
```

### 7.3 文件操作

#### 文件读写
```cangjie
import std.fs.*

// 读取文件
public func readHistory(filePath: Path) {
    var historyArray: ArrayList<Chat> = ArrayList<Chat>([])
    if (File.exists(filePath)) {
        var data = File.readFrom(filePath)
        // 处理数据
    }
    return historyArray.toArray()
}

// 写入文件
public func writeHistory(writeChat: Chat, filePath: Path) {
    var file: File
    if (!File.exists(filePath)) {
        file = File(filePath, OpenOption.Create(false))  // 新建文件
    } else {
        file = File(filePath, OpenOption.Append)  // 追加模式
        file.write(',\n'.toArray())
    }
    file.write(writeChat.toJson().toArray())
    file.close()
}
```

#### 异步文件选择
```cangjie
import ohos.file.picker.*

let callback = { error: ?AsyncError, result: ?PhotoSelectResult =>
    if (let Some(e) <- error) {
        // 处理错误
        return
    }
    if (let Some(r) <- result) {
        // 处理选中的文件
        let uris = r.photoUris
        // 更新 UI
    }
}

PhotoViewPicker().select(callback)
```

### 7.4 JSON 处理

```cangjie
import encoding.json.*

// 解析 JSON
let json = JsonValue.fromStr(jsonString).asObject()
let value = json.getFields()['key'].asString().getValue()

// 构建 JSON
let jsonObj = JsonObject()
jsonObj.setField('name', JsonString('value'))
let jsonString = jsonObj.toString()

// 序列化对象
func toJson(): String {
    let json = JsonObject()
    json.setField('field1', JsonString(this.field1))
    json.setField('field2', JsonNumber(this.field2))
    return json.toString()
}

// 反序列化
static func fromJson(jsonStr: String): Chat {
    let json = JsonValue.fromStr(jsonStr).asObject()
    let time = json.getFields()['time'].asString().getValue()
    // ...
    return Chat(time, messages)
}
```

### 7.5 错误处理

#### Option 类型处理
```cangjie
// 安全获取值
match (Router.getParams()) {
    case Some(v) => {
        // 使用 v
        url = v
    }
    case None => {
        // 处理 None 情况
        throw NoneValueException()
    }
}

// 使用 getOrThrow
let value = AppStorage.get<String>("key").getOrThrow()

// 使用 getOrElse
let value = AppStorage.get<String>("key").getOrElse("default")
```

#### 异常处理
```cangjie
try {
    // 可能抛出异常的操作
    let result = riskyOperation()
} catch (e: Exception) {
    // 处理异常
    Hilog.error(0, "tag", "Error: ${e.message}")
}
```

## 八、总结

### 8.1 仓颉语言特点

1. **声明式 UI**: 通过描述 UI 状态而非命令式操作
2. **响应式编程**: 状态变化自动触发 UI 更新
3. **类型安全**: 强类型系统提供编译时检查
4. **函数式支持**: 支持高阶函数和管道操作
5. **扩展性**: 通过 extend 扩展现有类型

### 8.2 开发体验

1. **简洁语法**: 代码简洁易读
2. **自动更新**: UI 自动响应状态变化
3. **组件化**: 良好的组件复用机制
4. **类型推断**: 减少类型声明代码

### 8.3 适用场景

- HarmonyOS 应用开发
- 声明式 UI 应用
- 需要强类型安全的项目
- 复杂状态管理应用

---

**注**: 本文档基于 HarmonyOS-Examples-main 项目分析整理，涵盖了仓颉语言在 HarmonyOS 开发中的核心概念和最佳实践。

